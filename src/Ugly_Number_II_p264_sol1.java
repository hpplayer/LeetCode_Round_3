/*
264. Ugly Number II

Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.

Note that 1 is typically treated as an ugly number.

Hint:

1. The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones.
2. An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.
3. The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3.
4. Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 * 5).
*/

/**
 * DP solution
 * 
 * We can create 3 virtual arrays and merge them to get the nth ugly number. Each virtual array corresponds to one prime base, and all numbers in this
 * virtual array will only be generated by multiply this prime base. Next smallest ugly number will be got from scan three arrays and choose the one
 * that gives the next smallest number. Since virtual arrays will be merged to dp array after n >= 3, so we can use three index pointers to get the 
 * values from virtual array
 * 
 * Time complexity: O(N)
 * Space complexity: O(N)
 * 
 * sol2 is heap solution
 * 
 * @author hpPlayer
 * @date Feb 25, 2016 12:58:26 AM
 */
public class Ugly_Number_II_p264_sol1 {
    public int nthUglyNumber(int n) {
        //dp solution, we keep 3 virtual arrays and merge them to get the nth num
        //virtual array will be included in dp array, therefore we can use three indexes to get the value in virtual array
        //its advanced version can be found in Super_Ugly_Number_p313_sol1
        
        //indexes that we can use to get head element in virtual array from dp array
        int index1 = 0, index2 = 0, index3 = 0;
        
        
        int[] dp = new int[n];
        dp[0] = 1;
        
        for(int i = 1; i < n; i++){
            //set the initial value to be int.max, so we can use Math.min() to get the min value
            dp[i] = Integer.MAX_VALUE;   
            
            //get the smallest value from three virtual arrays
            dp[i] = Math.min(dp[index1] * 2, Math.min(dp[index2] * 3, dp[index3] * 5));
            
            //we need to move index forward for those array that generate this min value
            if(dp[i] == dp[index1] * 2) index1++;
            if(dp[i] == dp[index2] * 3) index2++;
            if(dp[i] == dp[index3] * 5) index3++;
        }
        
        return dp[n-1];
    }
}
